//(c) Copyright 2015 Pivotal Software, Inc. All Rights Reserved.
'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isObject = require('lodash.isobject');
var flow = require('lodash.flow');
var _update = require('immutability-helper');
var warning = require('warning');

var async = true,
    debug = true;
var privates = new _weakMap2.default();

var Cursor = function () {
  (0, _createClass3.default)(Cursor, null, [{
    key: 'async',
    get: function get() {
      return async;
    },
    set: function set(bool) {
      async = bool;
    }
  }, {
    key: 'debug',
    get: function get() {
      return debug;
    },
    set: function set(bool) {
      debug = bool;
    }
  }]);

  function Cursor(data, callback) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref$path = _ref.path;
    var path = _ref$path === undefined ? [] : _ref$path;
    var _ref$state = _ref.state;
    var state = _ref$state === undefined ? { updates: [], data: data } : _ref$state;
    (0, _classCallCheck3.default)(this, Cursor);

    privates.set(this, { data: data, callback: callback, path: path, state: state });
  }

  Cursor.prototype.refine = function refine() {
    var _this = this;

    for (var _len = arguments.length, query = Array(_len), _key = 0; _key < _len; _key++) {
      query[_key] = arguments[_key];
    }

    var _privates$get = privates.get(this);

    var callback = _privates$get.callback;
    var data = _privates$get.data;
    var path = _privates$get.path;
    var state = _privates$get.state;

    query = query.reduce(function (memo, p) {
      return memo.push(isObject(p) ? _this.get.apply(_this, memo).indexOf(p) : p), memo;
    }, []);
    return new Cursor(data, callback, { path: path.concat(query), state: state });
  };

  Cursor.prototype.get = function get() {
    var _privates$get2 = privates.get(this);

    var data = _privates$get2.data;
    var path = _privates$get2.path;

    for (var _len2 = arguments.length, morePath = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      morePath[_key2] = arguments[_key2];
    }

    return path.concat(morePath).reduce(function (memo, step) {
      return memo[step];
    }, data);
  };

  Cursor.prototype.isEqual = function isEqual(otherCursor) {
    return this.get() === otherCursor.get();
  };

  Cursor.prototype.apply = function apply(options) {
    return this.update({ $apply: options });
  };

  Cursor.prototype.merge = function merge(options) {
    return this.update({ $merge: options });
  };

  Cursor.prototype.set = function set(options) {
    return this.update({ $set: options });
  };

  Cursor.prototype.push = function push() {
    for (var _len3 = arguments.length, options = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      options[_key3] = arguments[_key3];
    }

    return this.update({ $push: options });
  };

  Cursor.prototype.remove = function remove(obj) {
    var target = this.get();
    if (Array.isArray(target)) {
      var objArrayIndex = target.indexOf(obj);
      if (objArrayIndex === -1) return this.splice();
      return this.splice([objArrayIndex, 1]);
    }
    return this.apply(function (data) {
      return (0, _keys2.default)(data).filter(function (key) {
        return key !== obj.toString();
      }).reduce(function (memo, i) {
        return memo[i] = data[i], memo;
      }, {});
    });
  };

  Cursor.prototype.splice = function splice() {
    for (var _len4 = arguments.length, options = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      options[_key4] = arguments[_key4];
    }

    return this.update({ $splice: options });
  };

  Cursor.prototype.unshift = function unshift() {
    for (var _len5 = arguments.length, options = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      options[_key5] = arguments[_key5];
    }

    return this.update({ $unshift: options });
  };

  Cursor.prototype.nextTick = function nextTick(fn) {
    _promise2.default.resolve().then(fn).catch(function (error) {
      setTimeout(function () {
        throw error;
      }, 0);
    });
  };

  Cursor.prototype.flush = function flush() {
    var _privates$get3 = privates.get(this);

    var callback = _privates$get3.callback;
    var state = _privates$get3.state;

    if (!state.updates.length) return this;
    var fn = flow.apply(undefined, state.updates);
    state.updates = [];
    state.data = fn.call(this, state.data);
    if (Cursor.async) state.stale = true;
    callback(state.data);
    return this;
  };

  Cursor.prototype.update = function update(options) {
    var _privates$get4 = privates.get(this);

    var path = _privates$get4.path;
    var _privates$get4$state = _privates$get4.state;
    var updates = _privates$get4$state.updates;
    var stale = _privates$get4$state.stale;

    if (Cursor.debug) warning(!stale, 'You are updating a stale cursor, this is almost always a bug');
    var query = path.reduceRight(function (memo, step) {
      var _ref2;

      return _ref2 = {}, _ref2[step] = (0, _extends3.default)({}, memo), _ref2;
    }, options);
    updates.push(function (data) {
      return _update(data, query);
    });
    if (!Cursor.async) return this.flush();
    if (updates.length === 1) this.nextTick(this.flush.bind(this));
    return this;
  };

  return Cursor;
}();

module.exports = Cursor;